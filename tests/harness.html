<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>DOPPLER Test Harness</title>
  <link rel="stylesheet" href="/styles/rd.css">
  <style>
    body { padding: var(--space-lg); }
    h1 { margin-bottom: var(--space-md); }
    #status { margin-bottom: var(--space-md); }
    #results { display: none; }
    #results.show { display: block; }
    #log-panel {
      margin-top: var(--space-md);
      padding: var(--space-sm);
      border: var(--border-sm) solid var(--fg);
      max-height: 75vh;
      overflow: auto;
      background: var(--bg);
    }
    .log-line {
      font-family: var(--font-a);
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin-bottom: 2px;
    }
    .log-level {
      opacity: var(--opacity-muted);
      margin-right: var(--space-xs);
    }
    .section { margin-bottom: var(--space-md); }
    .output {
      padding: var(--space-sm);
      border-left: var(--border-md) solid var(--fg);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .stats { display: flex; gap: var(--space-lg); }
    .stat-value { font-size: 18px; font-weight: 600; }
    .row { display: flex; justify-content: space-between; padding: var(--space-sm) 0; border-bottom: var(--border-sm) solid var(--fg); }
    .row:last-child { border-bottom: none; }
    .fail { opacity: var(--opacity-muted); text-decoration: line-through; }
    #summary { margin-top: var(--space-md); padding-top: var(--space-md); border-top: var(--border-sm) solid var(--fg); font-weight: 600; }
  </style>
</head>
<body>
  <h1 class="type-h1" id="title">DOPPLER TEST HARNESS</h1>
  <div id="status" class="muted type-caption">Initializing...</div>
  <div id="results"></div>
  <div id="log-panel" class="type-caption"></div>

  <script type="module">
    // ==========================================================================
    // Log Bridge: console -> UI
    // ==========================================================================

    const logPanel = document.getElementById('log-panel');
    const originalConsole = {
      log: console.log.bind(console),
      error: console.error.bind(console),
      warn: console.warn.bind(console),
      debug: console.debug.bind(console),
    };

    function formatArg(arg) {
      if (arg instanceof Error) {
        return arg.stack || arg.message;
      }
      if (typeof arg === 'string') return arg;
      if (arg === null || arg === undefined) return String(arg);
      try {
        return JSON.stringify(arg);
      } catch {
        return String(arg);
      }
    }

    // Only show important messages in DOM panel to avoid excessive updates
    const DOM_LOG_PATTERNS = [
      /^\[DOPPLER:/,        // Completion signals
      /^\[Harness\]/,       // Harness status
      /^\[Loader\]/,        // Loading progress
      /^\[Model\]/,         // Model info
      /^\[GPU\]/,           // GPU info
      /^\[Token\]/,         // Generated tokens
      /^\[Benchmark\]/,     // Benchmark results
      /^\[Sim\]/,           // Simulation info
      /Error|WARN|error/i,  // Errors and warnings
    ];

    function shouldLogToDOM(text) {
      return DOM_LOG_PATTERNS.some(p => p.test(text));
    }

    function appendLog(level, args) {
      const line = document.createElement('div');
      line.className = 'log-line';
      const label = document.createElement('span');
      label.className = 'log-level';
      label.textContent = `[${level}]`;
      line.appendChild(label);
      line.append(` ${args.map(formatArg).join(' ')}`);
      logPanel.appendChild(line);
      logPanel.scrollTop = logPanel.scrollHeight;
    }

    console.log = (...args) => {
      const text = args.map(formatArg).join(' ');
      if (shouldLogToDOM(text)) {
        appendLog('log', args);
      }
      originalConsole.log(...args);
    };

    console.error = (...args) => {
      appendLog('error', args);  // Always show errors
      originalConsole.error(...args);
    };

    console.warn = (...args) => {
      appendLog('warn', args);  // Always show warnings
      originalConsole.warn(...args);
    };

    console.debug = (...args) => {
      // Debug messages skip DOM entirely - too verbose
      originalConsole.debug(...args);
    };

    window.addEventListener('error', (event) => {
      console.error(event.error || event.message);
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error(event.reason || 'Unhandled promise rejection');
    });

    console.log('[LogBridge] Console proxy active (harness)');

    // ==========================================================================
    // Unified Test Harness
    // Modes: kernels, inference, simulation, bench, training
    // ==========================================================================

    const params = new URLSearchParams(window.location.search);
    let runtimeConfig = null;
    let harnessConfig = null;
    const manifestUrl = params.get('manifestUrl') || params.get('autorunManifestUrl');

    function renderManifestResults(report) {
      const container = document.getElementById('results');
      container.innerHTML = '';
      const summary = document.createElement('div');
      const summaryText = report?.summary
        ? `${report.summary.passedRuns}/${report.summary.totalRuns} runs passed â€¢ ${Math.round(report.summary.durationMs)}ms`
        : 'Manifest completed';
      summary.className = 'section type-label';
      summary.textContent = summaryText;
      container.appendChild(summary);

      for (const run of report?.runs || []) {
        const row = document.createElement('div');
        const passed = (run.results || []).every((r) => r.passed || r.skipped);
        row.className = `row ${passed ? 'pass' : 'fail'}`;
        const label = run.label || run.modelId || run.suite || 'run';
        row.innerHTML = `<span>${passed ? '\u2713' : '\u2717'} ${label}</span><span class="type-caption muted">${run.suite || 'inference'}</span>`;
        container.appendChild(row);
      }

      container.classList.add('show');
    }

    async function runManifestMode(url) {
      const status = document.getElementById('status');
      status.textContent = 'Loading manifest...';
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`Failed to load manifest: ${resp.status}`);
      }
      const manifest = await resp.json();
      const { runBrowserManifest } = await import('../src/inference/browser-harness.js');
      const result = await runBrowserManifest(manifest, {
        onProgress: ({ index, total, label }) => {
          status.textContent = `Running ${index}/${total}: ${label}`;
        },
      });
      window.harnessReport = result.report;
      renderManifestResults(result.report);
      status.textContent = result.reportInfo?.path
        ? `Report saved: ${result.reportInfo.path}`
        : 'Manifest complete';
    }

    async function loadRuntimeConfig() {
      const { parseRuntimeOverridesFromURL } = await import('../src/inference/test-harness.js');
      const { getRuntimeConfig, setRuntimeConfig } = await import('../src/config/index.js');
      const { applyRuntimePreset, applyRuntimeConfigFromUrl } = await import('../src/inference/browser-harness.js');
      const runtimeOverrides = parseRuntimeOverridesFromURL(params);
      const runtimePreset = params.get('runtimePreset');
      const runtimeConfigUrl = params.get('runtimeConfigUrl');
      if (runtimeOverrides.runtimeConfig) {
        setRuntimeConfig(runtimeOverrides.runtimeConfig);
      } else if (runtimeConfigUrl) {
        await applyRuntimeConfigFromUrl(runtimeConfigUrl);
      } else if (runtimePreset) {
        await applyRuntimePreset(runtimePreset);
      }
      const resolved = getRuntimeConfig();
      const harness = resolved.shared?.harness;
      if (!harness) {
        throw new Error('runtime.shared.harness is required for the harness.');
      }
      runtimeConfig = resolved;
      harnessConfig = harness;
    }

    // ==========================================================================
    // Shared: GPU Initialization
    // ==========================================================================

    async function initGPU() {
      const { initializeDevice } = await import('../src/inference/test-harness.js');
      const caps = await initializeDevice();
      console.log(`[GPU] ${caps.adapterInfo?.device || 'unknown'}, ${caps.hasF16 ? 'f16' : 'f32'}/${caps.hasSubgroups ? 'subgroups' : 'no-subgroups'}, ${(caps.adapterInfo?.memorySize / 1e9 || 0).toFixed(1)}GB`);
      return caps;
    }

    // ==========================================================================
    // Mode: Kernels
    // ==========================================================================

    async function initKernelMode() {
      const { testHarness, getGPU } = await import('../tests/kernels/browser/test-page.js');

      // Wait for GPU init
      await new Promise(r => setTimeout(r, 100));
      const gpu = await getGPU();

      if (!gpu?.device) {
        throw new Error('WebGPU device not available');
      }

      console.log(`[GPU] ${gpu.adapterInfo?.description || 'unknown'}, ${gpu.capabilities?.hasF16 ? 'f16' : 'f32'}/${gpu.capabilities?.hasSubgroups ? 'subgroups' : 'no-subgroups'}, ${((gpu.adapterInfo?.memorySize || 0) / 1e9).toFixed(1)}GB`);

      // Expose test harness for UI automation
      window.testHarness = testHarness;

      // Expose render function for external callers
      window.renderResults = (testResults) => {
        const container = document.getElementById('results');
        let passed = 0, failed = 0, totalTime = 0;

        for (const r of testResults) {
          const row = document.createElement('div');
          row.className = `row ${r.passed ? 'pass' : 'fail'}`;
          row.innerHTML = `<span>${r.passed ? '\u2713' : '\u2717'} ${r.name}</span><span class="type-caption muted">${r.duration}ms</span>`;
          container.appendChild(row);

          if (r.passed) passed++; else failed++;
          totalTime += r.duration;
        }

        const summary = document.createElement('div');
        summary.id = 'summary';
        summary.innerHTML = `<span class="badge badge-filled">${passed}/${passed + failed} PASSED</span> <span class="muted">${totalTime}ms</span>`;
        container.appendChild(summary);

        container.classList.add('show');
        document.getElementById('status').style.display = 'none';
      };

      console.log('[KernelTests] Ready for test execution');
      return 'kernels';
    }

    // ==========================================================================
    // Mode: Training
    // ==========================================================================

    async function initTrainingMode() {
      const { trainingHarness } = await import('../tests/training/browser/test-page.js');

      await initGPU();
      window.trainingHarness = trainingHarness;

      window.renderResults = (testResults) => {
        const container = document.getElementById('results');
        let passed = 0, failed = 0, totalTime = 0;

        for (const r of testResults) {
          const row = document.createElement('div');
          row.className = `row ${r.passed ? 'pass' : 'fail'}`;
          row.innerHTML = `<span>${r.passed ? '\u2713' : '\u2717'} ${r.name}</span><span class="type-caption muted">${r.duration}ms</span>`;
          container.appendChild(row);

          if (r.passed) passed++; else failed++;
          totalTime += r.duration;
        }

        const summary = document.createElement('div');
        summary.id = 'summary';
        summary.innerHTML = `<span class="badge badge-filled">${passed}/${passed + failed} PASSED</span> <span class="muted">${totalTime}ms</span>`;
        container.appendChild(summary);

        container.classList.add('show');
        document.getElementById('status').style.display = 'none';
      };

      console.log('[TrainingTests] Ready for test execution');
      return 'training';
    }

    // ==========================================================================
    // Mode: Inference
    // ==========================================================================

    async function initInferenceMode() {
      const {
        discoverModels,
        createHttpShardLoader,
        fetchManifest,
        initializeDevice,
        createTestState,
      } = await import('../src/inference/test-harness.js');
      const { getRuntimeConfig } = await import('../src/config/index.js');
      const { createPipeline } = await import('../src/inference/pipeline.js');
      const { getDevice } = await import('../src/gpu/device.js');
      const { SIGNALS } = await import('../src/debug/index.js');

      const runtimeConfig = getRuntimeConfig();
      const harnessConfig = runtimeConfig.shared.harness;
      const paramModel = harnessConfig.modelId;
      const paramAutorun = harnessConfig.autorun;
      const paramSkipLoad = harnessConfig.skipLoad;
      if (!paramModel) {
        throw new Error('runtime.shared.harness.modelId must be set for inference mode.');
      }

      const baseUrl = new URL('../models', window.location.href).toString().replace(/\/$/, '');

      // Test state for external callers
      window.testState = createTestState();

      // Check if pipeline already exists from previous warm run
      const existingPipeline = window.pipeline;

      async function run() {
        const MODEL_URL = `${baseUrl}/${paramModel}`;
        const prompt = runtimeConfig.inference.prompt;
        if (!prompt) {
          throw new Error('runtime.inference.prompt must be set for inference tests.');
        }
        const maxTokens = runtimeConfig.inference.batching.maxTokens;
        const temperature = runtimeConfig.inference.sampling.temperature;
        const profile = runtimeConfig.shared.debug.profiler?.enabled === true;
        const debugTokens = runtimeConfig.inference.debugTokens === true;
        const hasProbes = runtimeConfig.shared.debug.probes?.length > 0;

        try {
          let pipeline;

          if (paramSkipLoad && existingPipeline) {
            console.log('[Warm] Reusing existing pipeline from previous run');
            pipeline = existingPipeline;
            window.testState.loaded = true;
          } else {
            console.log('[Loader] 1. Initializing WebGPU...');
            const caps = await initializeDevice();
            const device = getDevice();
            console.log(`[GPU] ${caps.adapterInfo?.device || 'unknown'}, ${caps.hasF16 ? 'f16' : 'f32'}/${caps.hasSubgroups ? 'subgroups' : 'no-subgroups'}, ${(caps.adapterInfo?.memorySize / 1e9 || 0).toFixed(1)}GB`);

            console.log('[Loader] 2. Loading manifest...');
            const manifest = await fetchManifest(`${MODEL_URL}/manifest.json`);
            const architecture = typeof manifest.architecture === 'string'
              ? manifest.architecture
              : (manifest.architecture ? JSON.stringify(manifest.architecture) : null);
            const modelLabel = architecture || manifest.modelType || paramModel;
            console.log(`[Model] ${modelLabel}, ${manifest.config?.num_hidden_layers} layers`);

            console.log('[Loader] 3. Loading model weights...');
            const loadShard = createHttpShardLoader(MODEL_URL, manifest, (msg) => console.log(`[Loader] ${msg}`));

            pipeline = await createPipeline(manifest, {
              storage: { loadShard },
              gpu: { device },
              baseUrl: MODEL_URL,
            });

            window.pipeline = pipeline;
            window.testState.loaded = true;
            console.log('[Model] Loaded');
          }

          console.log(`4. Generating from: "${prompt}"`);
          const tokens = [];
          const tokenIds = [];
          const startTime = performance.now();

          for await (const tokenText of pipeline.generate(prompt, {
            maxTokens,
            temperature,
            profile,
            disableCommandBatching: hasProbes,  // Probes require sync readbacks
            onToken: (tokenId, tokenText) => {
              tokenIds.push(tokenId);
              if (debugTokens) {
                console.log(`[Token] ${tokenIds.length}: id=${tokenId} text=${JSON.stringify(tokenText)}`);
              }
            },
          })) {
            tokens.push(tokenText);
            if (!debugTokens) {
              console.log(`[Token] ${tokens.length}: "${tokenText}"`);
            }
          }

          const elapsed = performance.now() - startTime;
          const tokPerSec = tokens.length / (elapsed / 1000);
          const output = tokens.join('');

          window.testState.output = output;
          window.testState.tokens = tokens;
          window.testState.tokenIds = tokenIds;
          window.testState.done = true;

          console.log(`${SIGNALS.RESULT} ${JSON.stringify({ output, tokens: tokens.length, elapsed, tokensPerSecond: tokPerSec })}`);
          console.log(`${SIGNALS.DONE} ${JSON.stringify({ status: 'success', elapsed, tokens: tokens.length, tokensPerSecond: tokPerSec })}`);

          renderInferenceResults({
            model: paramModel,
            prompt,
            output,
            tokens: tokens.length,
            elapsed: elapsed.toFixed(0),
            tokPerSec: tokPerSec.toFixed(1),
            passed: tokens.length > 0,
          });

        } catch (e) {
          console.error(e.stack);
          window.testState.errors.push(e.message);
          window.testState.done = true;
          console.log(`${SIGNALS.ERROR} ${JSON.stringify({ error: e.message })}`);
          console.log(`${SIGNALS.DONE} ${JSON.stringify({ status: 'error', elapsed: 0, error: e.message })}`);
          document.getElementById('status').textContent = `Error: ${e.message}`;
          document.getElementById('status').classList.add('border-error');
        }
      }

      function renderInferenceResults(r) {
        const container = document.getElementById('results');
        container.innerHTML = `
          <div class="section">
            <div class="type-label muted">Model</div>
            <div>${r.model}</div>
          </div>
          <div class="section">
            <div class="type-label muted">Prompt</div>
            <div>${r.prompt}</div>
          </div>
          <div class="section">
            <div class="type-label muted">Output</div>
            <div class="output">${r.output}</div>
          </div>
          <div class="section stats">
            <div class="stat">
              <div class="stat-value">${r.tokens}</div>
              <div class="type-caption muted">tokens</div>
            </div>
            <div class="stat">
              <div class="stat-value">${r.elapsed}ms</div>
              <div class="type-caption muted">total</div>
            </div>
            <div class="stat">
              <div class="stat-value">${r.tokPerSec}</div>
              <div class="type-caption muted">tok/s</div>
            </div>
          </div>
          <div class="section">
            <div class="${r.passed ? 'badge badge-filled' : 'badge border-error muted'}">${r.passed ? 'PASS' : 'FAIL'}</div>
          </div>
        `;
        container.classList.add('show');
        document.getElementById('status').style.display = 'none';
      }

      // Auto-run if requested
      if (paramAutorun) {
        document.getElementById('status').textContent = 'Running...';
        run();
      } else {
        document.getElementById('status').textContent = 'Ready (autorun disabled in config)';
      }

      return 'inference';
    }

    // ==========================================================================
    // Mode: Simulation
    // ==========================================================================

    async function initSimulationMode() {
      const { createTestState } = await import('../src/inference/test-harness.js');
      const { createEmulationContext, isEmulationSupported, getEmulationCapabilities } = await import('/proto/simulator/index.js');
      const { formatBytes } = await import('../src/config/schema/emulation.schema.js');

      const paramAutorun = harnessConfig.autorun;

      window.testState = createTestState();

      const emulationConfig = runtimeConfig?.emulation;
      if (!emulationConfig?.enabled) {
        throw new Error('runtime.emulation.enabled must be true for simulation mode.');
      }

      async function run() {
        try {
          const supported = await isEmulationSupported();
          if (!supported) {
            throw new Error('Simulation not supported (WebGPU or OPFS missing).');
          }

          const caps = await getEmulationCapabilities();
          console.log(`[Sim] Local resources: VRAM ${formatBytes(caps.estimatedVramBytes)}, RAM ${formatBytes(caps.estimatedRamBytes)}, Storage ${formatBytes(caps.estimatedStorageBytes)}`);
          console.log(`[Sim] Target chip: ${emulationConfig.targetChip}, timing: ${emulationConfig.timingMode}`);

          window.testState.loading = true;
          const ctx = await createEmulationContext(emulationConfig);
          window.simulation = ctx;
          window.testState.loading = false;
          window.testState.loaded = true;

          const stats = ctx.getStats();
          const statsJson = JSON.stringify(stats, null, 2);
          window.testState.output = statsJson;
          window.testState.done = true;

          renderSimulationResults({
            targetChip: emulationConfig.targetChip,
            timingMode: emulationConfig.timingMode,
            statsJson,
          });
        } catch (e) {
          console.error(e.stack || e.message);
          window.testState.errors.push(e.message);
          window.testState.done = true;
          document.getElementById('status').textContent = `Error: ${e.message}`;
          document.getElementById('status').classList.add('border-error');
        }
      }

      function renderSimulationResults(r) {
        const container = document.getElementById('results');
        container.innerHTML = `
          <div class="section">
            <div class="type-label muted">Target Chip</div>
            <div>${r.targetChip}</div>
          </div>
          <div class="section">
            <div class="type-label muted">Timing Mode</div>
            <div>${r.timingMode}</div>
          </div>
          <div class="section">
            <div class="type-label muted">Stats</div>
            <div class="output">${r.statsJson}</div>
          </div>
        `;
        container.classList.add('show');
      }

      if (paramAutorun) {
        document.getElementById('status').textContent = 'Running...';
        run();
      } else {
        document.getElementById('status').textContent = 'Ready (autorun disabled in config)';
      }

      return 'simulation';
    }

    // ==========================================================================
    // Mode: Bench
    // ==========================================================================

    async function initBenchMode() {
      // Benchmark mode just needs GPU ready - external caller can inject the benchmark script
      await initGPU();

      // Signal ready for benchmark injection
      window.dopplerReady = true;

      console.log('[Bench] Ready for benchmark injection');
      document.getElementById('status').textContent = 'Ready for benchmark';
      return 'bench';
    }

    // ==========================================================================
    // Main
    // ==========================================================================

    async function main() {
      if (manifestUrl) {
        document.getElementById('title').textContent = 'DOPPLER HARNESS MANIFEST';
        try {
          await runManifestMode(manifestUrl);
        } catch (e) {
          console.error(`[Harness] Error: ${e.message}`);
          document.getElementById('status').textContent = `Error: ${e.message}`;
          document.getElementById('status').classList.add('border-error');
          window.harnessError = e.message;
        }
        return;
      }
      await loadRuntimeConfig();
      const mode = harnessConfig.mode;
      const titles = {
        kernels: 'DOPPLER KERNEL TESTS',
        inference: 'DOPPLER INFERENCE TEST',
        simulation: 'DOPPLER SIMULATION',
        bench: 'DOPPLER BENCHMARK',
        training: 'DOPPLER TRAINING TESTS',
      };
      document.getElementById('title').textContent = titles[mode] || 'DOPPLER TEST HARNESS';

      console.log(`[Harness] Mode: ${mode}`);
      document.getElementById('status').textContent = `Initializing ${mode} mode...`;

      try {
        let result;
        switch (mode) {
          case 'kernels':
            result = await initKernelMode();
            break;
          case 'training':
            result = await initTrainingMode();
            break;
          case 'inference':
            result = await initInferenceMode();
            break;
          case 'simulation':
            result = await initSimulationMode();
            break;
          case 'bench':
            result = await initBenchMode();
            break;
          default:
            throw new Error(`Unknown mode: ${mode}`);
        }
        document.getElementById('status').textContent = 'Ready';
        console.log(`[Harness] ${result} mode initialized`);
      } catch (e) {
        console.error(`[Harness] Error: ${e.message}`);
        document.getElementById('status').textContent = `Error: ${e.message}`;
        document.getElementById('status').classList.add('border-error');
        window.harnessError = e.message;
      }
    }

    main();
  </script>
</body>
</html>
