<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>DOPPLER Inference Test</title>
  <link rel="stylesheet" href="/doppler/app/rd.css">
  <style>
    /* Test page layout only - all component styling from rd.css */
    body { padding: var(--space-lg); }
    h1 { margin-bottom: var(--space-md); }
    #status { margin-bottom: var(--space-md); }
    #results { display: none; }
    #results.show { display: block; }
    .section { margin-bottom: var(--space-md); }
    .output {
      padding: var(--space-sm);
      border-left: var(--border-md) solid var(--fg);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .stats { display: flex; gap: var(--space-lg); }
    .stat-value { font-size: 18px; font-weight: 600; }
  </style>
</head>
<body>
  <h1 class="type-h1">DOPPLER INFERENCE TEST</h1>
  <div id="status" class="muted type-caption">Initializing...</div>
  <div id="results"></div>

  <script type="module">
    import {
      discoverModels,
      parseRuntimeOverridesFromURL,
      createHttpShardLoader,
      fetchManifest,
      initializeDevice,
      createTestState,
    } from '/doppler/dist/inference/test-harness.js';
    import { setRuntimeConfig } from '/doppler/dist/config/index.js';
    import { createPipeline } from '/doppler/dist/inference/pipeline.js';
    import { getDevice } from '/doppler/dist/gpu/device.js';
    import { SIGNALS } from '/doppler/dist/debug/index.js';

    // Parse query params
    const params = new URLSearchParams(window.location.search);
    const paramModel = params.get('model') || 'gemma-3-1b-it-q4';
    const paramAutorun = params.get('autorun') === '1';
    const paramSkipLoad = params.get('skipLoad') === '1';
    const runtimeOverrides = parseRuntimeOverridesFromURL(params);
    if (runtimeOverrides.runtimeConfig) {
      setRuntimeConfig(runtimeOverrides.runtimeConfig);
    }

    const BASE_URL = 'http://localhost:8080/doppler/models';

    // Test state for Playwright
    window.testState = createTestState();

    // Check if pipeline already exists from previous warm run
    const existingPipeline = window.pipeline;

    async function run() {
      const MODEL_URL = `${BASE_URL}/${paramModel}`;
      const configPrompt = runtimeOverrides.runtimeConfig?.inference?.prompt;
      const prompt = params.get('prompt') || configPrompt || 'The color of the sky is';
      const maxTokens = parseInt(params.get('maxTokens') || '8', 10);
      const temperature = parseFloat(params.get('temperature') || '0');
      // Chat template: only override if explicitly set via URL param
      // - noChat=1 → disable chat template
      // - chat=1 → enable chat template
      // - neither → use model preset default (chatTemplate.enabled)
      const chatOverride = params.has('noChat') ? false : params.has('chat') ? true : undefined;

      try {
        let pipeline;

        // Skip loading if --skip-load and pipeline already exists
        if (paramSkipLoad && existingPipeline) {
          console.log('[Warm] Reusing existing pipeline from previous run');
          pipeline = existingPipeline;
          window.testState.loaded = true;
        } else {
          console.log('1. Initializing WebGPU...');

          // 1. Init GPU
          const caps = await initializeDevice();
          const device = getDevice();
          console.log(`[GPU] ${caps.adapterInfo?.device || 'unknown'}, ${caps.hasF16 ? 'f16' : 'f32'}/${caps.hasSubgroups ? 'subgroups' : 'no-subgroups'}, ${(caps.adapterInfo?.memorySize / 1e9 || 0).toFixed(1)}GB`);

          if (runtimeOverrides.kernelPath) {
            console.log(`[KernelPath] Runtime overrides: ${JSON.stringify(runtimeOverrides.kernelPath)}`);
          }

          // 2. Load manifest
          console.log('2. Loading manifest...');
          const manifest = await fetchManifest(`${MODEL_URL}/manifest.json`);
          console.log(`[Model] ${manifest.architecture || paramModel}, ${manifest.config?.num_hidden_layers} layers`);

          // 3. Create pipeline
          console.log('3. Loading model weights...');
          const loadShard = createHttpShardLoader(MODEL_URL, manifest, (msg) => console.log(`[Loader] ${msg}`));

          pipeline = await createPipeline(manifest, {
            storage: { loadShard },
            gpu: { device },
            baseUrl: MODEL_URL,
            runtime: {
              debug: runtimeOverrides.debug,
              kernelPath: runtimeOverrides.kernelPath,
            },
          });

          // Expose pipeline globally for warm mode reuse
          window.pipeline = pipeline;
          window.testState.loaded = true;
          console.log('[Model] Loaded (pipeline stored in window.pipeline for reuse)');
        }

        // 4. Generate - console.log only, no DOM updates
        console.log(`4. Generating from: "${prompt}"`);
        const tokens = [];
        const startTime = performance.now();

        for await (const tokenText of pipeline.generate(prompt, {
          maxTokens,
          temperature,
          // Only pass useChatTemplate if explicitly overridden, else use model default
          ...(chatOverride !== undefined && { useChatTemplate: chatOverride }),
        })) {
          tokens.push(tokenText);
          console.log(`[Token] ${tokens.length}: "${tokenText}"`);
        }

        const elapsed = performance.now() - startTime;
        const tokPerSec = tokens.length / (elapsed / 1000);
        const output = tokens.join('');

        window.testState.output = output;
        window.testState.tokens = tokens;
        window.testState.done = true;

        // Emit standardized completion signals for CLI/automation detection
        console.log(`${SIGNALS.RESULT} ${JSON.stringify({ output, tokens: tokens.length, elapsed, tokensPerSecond: tokPerSec })}`);
        console.log(`${SIGNALS.DONE} ${JSON.stringify({ status: 'success', elapsed, tokens: tokens.length, tokensPerSecond: tokPerSec })}`);

        // 5. Single DOM update at end
        renderResults({
          model: paramModel,
          prompt,
          output,
          tokens: tokens.length,
          elapsed: elapsed.toFixed(0),
          tokPerSec: tokPerSec.toFixed(1),
          passed: tokens.length > 0,
        });

      } catch (e) {
        console.error(e.stack);
        window.testState.errors.push(e.message);
        window.testState.done = true;
        // Emit standardized error signals for CLI/automation detection
        console.log(`${SIGNALS.ERROR} ${JSON.stringify({ error: e.message })}`);
        console.log(`${SIGNALS.DONE} ${JSON.stringify({ status: 'error', elapsed: 0, error: e.message })}`);
        document.getElementById('status').textContent = `Error: ${e.message}`;
        document.getElementById('status').classList.add('border-error');
      }
    }

    function renderResults(r) {
      const container = document.getElementById('results');
      container.innerHTML = `
        <div class="section">
          <div class="type-label muted">Model</div>
          <div>${r.model}</div>
        </div>
        <div class="section">
          <div class="type-label muted">Prompt</div>
          <div>${r.prompt}</div>
        </div>
        <div class="section">
          <div class="type-label muted">Output</div>
          <div class="output">${r.output}</div>
        </div>
        <div class="section stats">
          <div class="stat">
            <div class="stat-value">${r.tokens}</div>
            <div class="type-caption muted">tokens</div>
          </div>
          <div class="stat">
            <div class="stat-value">${r.elapsed}ms</div>
            <div class="type-caption muted">total</div>
          </div>
          <div class="stat">
            <div class="stat-value">${r.tokPerSec}</div>
            <div class="type-caption muted">tok/s</div>
          </div>
        </div>
        <div class="section">
          <div class="${r.passed ? 'badge badge-filled' : 'badge border-error muted'}">${r.passed ? 'PASS' : 'FAIL'}</div>
        </div>
      `;
      container.classList.add('show');
      document.getElementById('status').style.display = 'none';
    }

    // Auto-run if requested
    if (paramAutorun) {
      document.getElementById('status').textContent = 'Running...';
      run();
    } else {
      document.getElementById('status').textContent = 'Add ?autorun=1 to URL to run';
    }
  </script>
</body>
</html>
